// SPDX-License-Identifier: GPL-2.0

//! Rust file system sample.

use kernel::module_fs;
use kernel::prelude::*;
use kernel::{
    c_str, file, fs,
    io_buffer::IoBufferWriter,
    sync::{Arc, ArcBorrow},
};

mod puzzle;
// Required by the autogenerated '_capnp.rs' files
use puzzle::inode::{file_read, PuzzleFS};
use puzzle::types::{Inode, InodeMode};
use puzzle::{manifest_capnp, metadata_capnp};

use kernel::fs::{DEntry, INodeParams, NeedsRoot, NewSuperBlock, RootDEntry};

module_fs! {
    type: PuzzleFsModule,
    name: "puzzlefs",
    author: "Ariel Miculas",
    license: "GPL",
}

struct PuzzleFsModule;

struct PuzzlefsInfo {
    puzzlefs: Arc<PuzzleFS>,
}

#[vtable]
impl fs::Context<Self> for PuzzleFsModule {
    type Data = ();

    kernel::define_fs_params! {(),
        {flag, "flag", |_, v| { pr_info!("flag passed-in: {v}\n"); Ok(()) } },
        {flag_no, "flagno", |_, v| { pr_info!("flagno passed-in: {v}\n"); Ok(()) } },
        {bool, "bool", |_, v| { pr_info!("bool passed-in: {v}\n"); Ok(()) } },
        {u32, "u32", |_, v| { pr_info!("u32 passed-in: {v}\n"); Ok(()) } },
        {u32oct, "u32oct", |_, v| { pr_info!("u32oct passed-in: {v}\n"); Ok(()) } },
        {u32hex, "u32hex", |_, v| { pr_info!("u32hex passed-in: {v}\n"); Ok(()) } },
        {s32, "s32", |_, v| { pr_info!("s32 passed-in: {v}\n"); Ok(()) } },
        {u64, "u64", |_, v| { pr_info!("u64 passed-in: {v}\n"); Ok(()) } },
        {string, "string", |_, v| { pr_info!("string passed-in: {v}\n"); Ok(()) } },
        {enum, "enum", [("first", 10), ("second", 20)], |_, v| {
            pr_info!("enum passed-in: {v}\n"); Ok(()) }
        },
    }

    fn try_new() -> Result {
        Ok(())
    }
}

fn puzzlefs_populate_dir(
    sb: &NewSuperBlock<'_, PuzzleFsModule, NeedsRoot>,
    pfs: &PuzzleFS,
    parent: &DEntry<PuzzleFsModule>,
    ino: u64,
    name: &CStr,
    recursion: usize,
) -> Result {
    if recursion == 0 {
        return Err(E2BIG);
    }

    let inode = Arc::try_new(pfs.find_inode(ino)?)?;
    match &inode.mode {
        InodeMode::File { chunks: _ } => {
            let params = INodeParams {
                mode: inode.permissions,
                ino: inode.ino,
                value: inode.clone(),
            };
            let creator = fs::file_creator::<_, FsFile>();
            let inode = creator(sb, params)?;
            sb.try_new_dentry(inode, parent, name)?;
        }
        InodeMode::Dir { dir_list } => {
            let params = INodeParams {
                mode: inode.permissions,
                ino: inode.ino,
                value: inode.clone(),
            };

            let new_dentry;
            let new_parent = if name.as_bytes() != c_str!("").as_bytes() {
                let dcache_inode = sb.sb.try_new_dcache_dir_inode(params)?;
                new_dentry = sb.try_new_dentry(dcache_inode, parent, name)?;
                &new_dentry
            } else {
                parent
            };

            for entry in &dir_list.entries {
                let mut name = entry.name.try_clone()?;
                // append NUL terminator
                name.try_push(0)?;
                let name = CStr::from_bytes_with_nul(&name)?;
                puzzlefs_populate_dir(sb, pfs, new_parent, entry.ino, name, recursion - 1)?;
            }
        }
        _ => todo!(),
    }

    Ok(())
}

/// Creates a new root dentry populated with the given entries.
fn try_new_populated_root_puzzlefs_dentry(
    sb: &NewSuperBlock<'_, PuzzleFsModule, NeedsRoot>,
    pfs: &PuzzleFS,
    root_value: <PuzzleFsModule as fs::Type>::INodeData,
) -> Result<RootDEntry<PuzzleFsModule>> {
    let root_inode = sb.sb.try_new_dcache_dir_inode(INodeParams {
        mode: 0o755,
        ino: root_value.ino,
        value: root_value,
    })?;
    let root = sb.try_new_root_dentry(root_inode)?;
    let ino = 1u64;
    puzzlefs_populate_dir(sb, pfs, &root, ino, c_str!(""), 10)?;
    Ok(root)
}

impl fs::Type for PuzzleFsModule {
    type Context = Self;
    // this is Arc so it can be cloned in puzzlefs_populate_dir
    type INodeData = Arc<Inode>;
    type Data = Box<PuzzlefsInfo>;
    const SUPER_TYPE: fs::Super = fs::Super::Independent;
    const NAME: &'static CStr = c_str!("puzzlefs");
    const FLAGS: i32 = fs::flags::USERNS_MOUNT;
    const DCACHE_BASED: bool = true;

    fn fill_super(_data: (), sb: fs::NewSuperBlock<'_, Self>) -> Result<&fs::SuperBlock<Self>> {
        let puzzlefs = PuzzleFS::open(
            c_str!("/home/puzzlefs_oci"),
            c_str!("2d6602d678140540dc7e96de652a76a8b16e8aca190bae141297bcffdcae901b"),
        );

        if let Err(ref e) = puzzlefs {
            pr_info!("error opening puzzlefs {e}\n");
        }

        let puzzlefs = Arc::try_new(puzzlefs?)?;

        let sb = sb.init(
            Box::try_new(PuzzlefsInfo {
                puzzlefs: puzzlefs.clone(),
            })?,
            &fs::SuperParams {
                magic: 0x72757374,
                ..fs::SuperParams::DEFAULT
            },
        )?;

        let root_inode = Arc::try_new(puzzlefs.find_inode(1)?)?;

        let root = try_new_populated_root_puzzlefs_dentry(&sb, &puzzlefs, root_inode)?;
        let sb = sb.init_root(root)?;
        Ok(sb)
    }
}

struct FsFile;

#[vtable]
impl file::Operations for FsFile {
    // must be the same as INodeData
    type OpenData = Arc<Inode>;
    type Filesystem = PuzzleFsModule;
    // this is an Arc because Data must be ForeignOwnable and the only implementors of it are Box,
    // Arc and (); we cannot pass a reference to the read callback, so we share PuzzleFS using Arc
    type Data = Arc<PuzzleFS>;

    fn open(
        fs_info: &PuzzlefsInfo,
        _context: &Self::OpenData,
        _file: &file::File,
    ) -> Result<Self::Data> {
        Ok(fs_info.puzzlefs.clone())
    }

    fn read(
        data: ArcBorrow<'_, PuzzleFS>,
        file: &file::File,
        writer: &mut impl IoBufferWriter,
        offset: u64,
    ) -> Result<usize> {
        let inode = file.inode::<PuzzleFsModule>().ok_or(EINVAL)?.fs_data();
        let mut buf = Vec::try_with_capacity(writer.len())?;
        buf.try_resize(writer.len(), 0)?;
        let read = file_read(&data.oci, inode, offset as usize, &mut buf)?;
        buf.truncate(read);
        file::read_from_slice(&buf, writer, 0)
    }
}
